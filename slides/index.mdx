import Code from 'mdx-code';
import { Appear } from 'mdx-deck'
import { Head } from 'mdx-deck'
import { Image } from 'mdx-deck'
import { FullScreenCode } from 'mdx-deck/layouts'
import { Split } from 'mdx-deck/layouts'
import { SplitRight } from 'mdx-deck/layouts'
import { CodeSurfer } from "mdx-deck-code-surfer"
import { LiveCode } from 'mdx-deck-live-code';

import CustomLayout from '../components/CustomLayout'

<Head>
  <title>Full Stack optimization with gRPC and gRPC-web</title>
</Head>

<img style={{ width: '200px', height:'71px', marginBottom: '2vh'}} src='assets/svg/grpc.svg' />

----

Full Stack optimization with  
gRPC and gRPC-web

```notes
- "Welcome!"
- Introduce yourself
```

---

# Agenda

- Microservices and the new challenges
- gRPC, Protobuf and tools
- gRPC-web nowadays
- Demos üôè

```notes
- Overview:
  - IT architecture evolution and the needs in this new environment 
  - The rising of gRPC
  - How the gRPC-web fit today
- "Start pray for gods of live-demo!"
```

---

# Monolith vs. Microservices

```notes
- But before explain gRPC and gRPC-web:
  - talk about IT architecture evolution
  - state of microservices nowadays and future
```

---

![](assets/img/architecture_evolution_ballerina.png)

```notes
- Past: 
  - mainframes, legacy
- Today: 
  - serveless: (AWS: Lambda; Google-Firebase: Cloud functions)
- microservices:  
  - atomic
  - desacopled 
- "Endpoints.. endpoints everywhere!"
```

---

export default CustomLayout

> "Write programs that do one thing and do it well. Write programs to work together."  
‚Äî [Unix Philosophy](https://en.wikipedia.org/wiki/Unix_philosophy)

```notes
- Unix programs:
  - single responsibility
  - small 
  - good interface communication
```

---

# Great! But... 

```notes
- Also great for development:
  - desacopled teams:
    - flexibility
    - independence 
    - fast 
    - single responsibility
- But...
```

---

<Image src='assets/img/uncle_ben.webp' />

```notes
- ‚ÄúWith Great Power Comes Great Responsibility‚Äù ‚Äî Uncle Ben
- and Big problems too!
```

---

export default CustomLayout

> "The biggest issue in changing a monolith into microservices lies in changing the communication pattern"  
‚Äî [Martin Flower](https://martinfowler.com/articles/microservices.html)

```notes
- Communication:
  - simple
  - fast
  - smart
```

---

# Communication!

- SOAP ...... XML
- REST ...... JSON
- gRPC ...... Protobuffer

```notes
- != patterns of communication
- self describe
- interface: rigid vs. flexibility
- HTTP verbs vs. methods call
- errors and returns code

Obs: 
- RESTful well documented with OpenAPI (Swagger): üëå  
  - a deal, without guarantees üò≠
```

---

# [gRPC](https://grpc.io/)

- RPC framework defined on top of **HTTP/2**
- **Protobuf** integrations
- Implementation in ~10 languages
- Streaming capabilities
- Feature rich

```notes
- gRPC 1.0: released in August 2016
- support for polyglot environments
- focus on performance
- type safety 
- developer productivity: transformed the way developers design their architectures
```

---

# [HTTP/2](https://tools.ietf.org/html/rfc7540)

- Data compression of HTTP headers
- Server-side Push
- Pipelining of requests
- Multiplexing multiple requests over a single TCP connection

```notes
- origin in Google SPDY protocol
- fix some problems in HTTP 1.x
- high-level compatibility with HTTP 1.1:
  - methods, status codes, URIs, and most header fields
```

---

# [Protobuffer](https://developers.google.com/protocol-buffers)

- IDL (Interface definition language)
- Data model
- Wire format

<h5>"think XML, but smaller, faster, and simpler"</h5> 

```notes
- IDL:
  - Describe once and generate Interface for any language
- Data Model:
  - Structure of the request and response 
- Wire format:
  - Binary format for network transmission
```

---

```protobuf
syntax = "proto3";

package helloworld;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
  rpc RepeatHello (HelloRequest) returns (stream HelloReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```

```notes
- current syntax version: 3.0
- define request and response
- define service methods
- can use streams
```

---

#  JSON vs. Protobuffer

- Text vs. Binary
- Flexibility vs. Well defined types
- Errors catch
- (De)serialization

```notes
- Text format transportation is bigger then binary 
- JSON more flexible:
  - can send dynamic data and don't have to adhere to a rigid structure
- Errors catch:
  - Protobuf: you know the request and response format
  - JSON: you can know the expect format, but no garantees
- (De)serialization:
  - can introduces the possibility of errors  
  - as well as performance overhead
```

---

![](assets/img/grpc_services.png)

```notes
- In gRPC, a client application can directly call methods of a server application that is on a different machine as if it was a local object. 
- On the server side, the server implements and runs a gRPC server to handle client calls. 
- On the client side, the client has a stub that provides the same methods as the server.
```

---

# [protoc](https://github.com/protocolbuffers/protobuf/releases)

- compile `.proto` files
- code-generator 
- plugins

```
protoc --go_out=. inputs/hello.proto
```

```notes
- Golang example, but offer generation of clients for ~10 languages
- code-generator of messages and method stubs 
- extensible with plugins
```

---

# [gRPC-web](https://grpc.io/docs/tutorials/basic/web.html)

- "gRPC looks great. Can I use it on the web?" ü§î 
- [limitations](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) don't allow implements the full gRPC protocol in the web browser 
- proposed new gRPC-web [specification](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md): currently implemented in [Envoy](https://envoyproxy.io/)

```notes
- Limitations:
  - Standard Web APIs (XHR, Fetch) don‚Äôt expose HTTP wire-transport details:
    - don't expose the concepts of channel, frames and byte manipulation, that are necessary to implements binary gRPC protocol 
  - Web clients prefers text data: security, JSON compatible encoding, streaming
  - Response trailers are not supported
  - Web-specific features: CORS, security (XSRF/CSP), etc
  - Firewall, corporate proxies restrictions, etc
```

---

![](assets/img/grpc_web_grpc_services.png)

```notes
- How to do this?
```

---

# #01 REST with gRPC

![](assets/img/rest_grpc.png)

```notes
- No problem with this approach, but:
  - definition of HTTP status codes 
  - JSON (De)serialization
  - deployment and management burden for the HTTP server itself
```

---

# Implementations

Google:
- [grpc-web](https://www.npmjs.com/package/grpc-web): client in JavaScript
- [Envoy](https://www.envoyproxy.io/docs/envoy/latest/configuration/http_filters/grpc_web_filter): reverse proxy HTTP filter

```notes
- WRITE SOME NOTES HERE
```

---

# Implementations

Improbable:
- [@improbable-eng/grpc-web](https://www.npmjs.com/package/@improbable-eng/grpc-web): client in TypeScript
- [grpcweb](https://github.com/improbable-eng/grpc-web/tree/master/go/grpcweb): a wrapper around a gRPC-Go Server
- [grpcwebproxy](https://github.com/improbable-eng/grpc-web/tree/master/go/grpcwebproxy): standalone reverse proxy

```notes
- WRITE SOME NOTES HERE
```

---

# Improbable overview

![](assets/img/grpc_web_improbable_overview.png)

```notes
- Overview of Improbable libraries utilization
```

---

# #02 gRPC-web with Envoy

![](assets/img/grpc_web_envoy_grpc.png)

```notes
- Envoy reversal proxy doing all the hard work!
```

---

<CodeSurfer
  title="Envoy Configuration"
  code={require("!raw-loader!snippets/envoy-grpc-web-config.yaml")}
  dark={true}
  steps={[
    { notes: "Envoy proxy configuration to run gRCP-web" },
    { lines: [26, 30], notes: "Allow grpc-web headers" },
    { lines: [32], notes: "Expose grpc-web headers" },
    { range: [34, 37], notes: "Add grpc-web to http filters" },
    { lines: [42], notes: "The service takes HTTP/2 connections (gRPC)" }
  ]}
/>

```notes
- Envoy yaml config:
  - Atypical headers  "x-grpc-web", "grpc-status", and "grpc-message"‚Ää‚Äî‚Ääare required for handling gRPC-Web client requests
  - "envoy.grpc_web" HTTP filter performs the ‚Äúheavy lifting‚Äù for gRPC-Web proxying
  - The "http2_protocol_options: {}" specifies that the service takes HTTP/2 (in this case gRPC) connections
```

---

# #03 gRPC-web in server

![](assets/img/grpc_web_grpc.png)

```notes
- Server handle gRCP-web connections and doing the hard work
```

---

# Advantages

- End-to-end gRPC 
- Tighter coordination between frontend and backend teams: `.proto` as source of truth
- Easily generate client libraries 

```notes
- pure gRPC, enabling you to craft your entire RPC pipeline using Protocol Buffers. 
- no longer need to have your ‚Äúmicroservices teams‚Äù alongside your ‚Äúclient team‚Äù 
- client libraries can be gRPC libraries: ~10 languages
```

---

# Demos

```notes
- server x server:
  - REST x REST
  - gRPC x gRPC
- web x server:
  - gRPC-web x Envoy x gRCP
  - gRPC-web x gRPC server
```

---

# Results

```notes
- WRITE SOME NOTES HERE
```

---

# EXTRAS

```notes
- Tools and projects to check: 
  - gRPC-gateway
  - BloomRPC
```

---

# [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)

gRPC to JSON proxy generator

![](assets/img/grpc_gateway.png)

```notes
- Is a plugin for protoc.
- It reads gRPC service definition, and generates a reverse-proxy server which translates a RESTful JSON API into gRPC.
- This server is generated according to the google.api.http annotation in your gRPC service definition.
- It helps you to provide your APIs in both gRPC and RESTful style at the same time.
```

---

<CodeSurfer
  title="Sample Service"
  code={require("!raw-loader!snippets/grpc-gateway-snippet.proto")}
  dark={true}
  steps={[
    { notes: "Generated according to the google.api.http annotations" },
    { lines: [5], notes: "Import the annotations" },
    { range: [13, 16], notes: "Define the Rest endpoint" }
  ]}
/>

---

export default SplitRight

<img style={{ width: '600px'}} src='assets/img/bloomrpc_editor_preview.gif' />

![](assets/img/bloomrpc_logo.png)

[BloomRPC](https://github.com/uw-labs/bloomrpc)


```notes
- The missing GUI Client for GRPC services 
- Like Postman or Insomnia
```

---

# Conclusion

- üìà number of microservices: üí¨ communication becomes a problem!
- JSON -> Protobuffer | HTTP/1.x -> HTTP/2.0
- gRPC will become dominant very soon?
- gRPC-web ready? [ROADMAP](https://github.com/grpc/grpc-web/blob/master/ROADMAP.md)

```notes
- WRITE SOME NOTES HERE
```



















---

export default FullScreenCode

```jsx
<Button>Beep</Button>
```

```notes
- WRITE SOME NOTES HERE
```

---


export default Code

```javascript A playground slide!
console.log('Hello world');
```
---

<LiveCode
  title="How to greet people"
  size="small"
  code="<p>Hello World!</p>"
/>

```notes
- WRITE SOME NOTES HERE
```

---

export default CustomLayout

# Custom Layout

Custom Layout

```notes
- WRITE SOME NOTES HERE
```

---

# But is all JS ü§î

- Browser `!==` Server
- [grpc-node](https://github.com/grpc/grpc-node): use a Node C++ Addon
- Communication inter-microservices

```notes
- WRITE SOME NOTES HERE
```